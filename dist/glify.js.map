{"version":3,"sources":["canvas-overlay.ts","errors.ts","map-matrix.ts","base-gl-layer.ts","color.ts","line-feature-vertices.ts","utils.ts","lines.ts","points.ts","shapes.ts","index.ts"],"names":[],"mappings":"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","file":"glify.js","sourceRoot":"../src","sourcesContent":["/*\noriginally taken from: http://www.sumbera.com/gist/js/leaflet/canvas/L.CanvasOverlay.js, added and customized as part of this lib because of need from library\n Generic  Canvas Overlay for leaflet,\n Stanislav Sumbera, April , 2014\n\n - added userDrawFunc that is called when Canvas need to be redrawn\n - added few useful params fro userDrawFunc callback\n - fixed resize map bug\n inspired & portions taken from  :   https://github.com/Leaflet/Leaflet.heat\n */\n\nimport {\n  LatLngBounds,\n  Point,\n  Layer,\n  Util,\n  Browser,\n  Bounds,\n  DomUtil,\n  LatLng,\n  ZoomAnimEvent,\n  Map,\n  ResizeEvent,\n  LayerOptions,\n} from \"leaflet\";\n\nexport interface ICanvasOverlayDrawEvent {\n  canvas: HTMLCanvasElement;\n  bounds: LatLngBounds;\n  offset: Point;\n  scale: number;\n  size: Point;\n  zoomScale: number;\n  zoom: number;\n}\n\nexport type IUserDrawFunc = (event: ICanvasOverlayDrawEvent) => void;\n\nexport type RedrawCallback = (instance: CanvasOverlay) => void;\n\nexport class CanvasOverlay extends Layer {\n  _userDrawFunc: IUserDrawFunc;\n  _redrawCallbacks: RedrawCallback[];\n  canvas?: HTMLCanvasElement;\n  _pane: string;\n\n  _frame?: number | null;\n  options?: LayerOptions;\n\n  constructor(userDrawFunc: IUserDrawFunc, pane: string) {\n    super();\n    this._userDrawFunc = userDrawFunc;\n    this._frame = null;\n    this._redrawCallbacks = [];\n    this._pane = pane;\n  }\n\n  drawing(userDrawFunc: IUserDrawFunc): this {\n    this._userDrawFunc = userDrawFunc;\n    return this;\n  }\n\n  params(options: any): this {\n    Util.setOptions(this, options);\n    return this;\n  }\n\n  redraw(callback?: RedrawCallback) {\n    if (typeof callback === \"function\") {\n      this._redrawCallbacks.push(callback);\n    }\n    if (this._frame === null) {\n      this._frame = Util.requestAnimFrame(this._redraw, this);\n    }\n    return this;\n  }\n\n  isAnimated(): boolean {\n    return Boolean(this._map.options.zoomAnimation && Browser.any3d);\n  }\n\n  onAdd(map: Map): this {\n    this._map = map;\n    const canvas = (this.canvas =\n      this.canvas ?? document.createElement(\"canvas\"));\n\n    const size = map.getSize();\n    const animated = this.isAnimated();\n    canvas.width = size.x;\n    canvas.height = size.y;\n    canvas.className = `leaflet-zoom-${animated ? \"animated\" : \"hide\"}`;\n\n    const pane = map.getPane(this._pane);\n    if (!pane) {\n      throw new Error(\"unable to find pane\");\n    }\n    pane.appendChild(this.canvas);\n\n    map.on(\"moveend\", this._reset, this);\n    map.on(\"resize\", this._resize, this);\n\n    if (animated) {\n      map.on(\n        \"zoomanim\",\n        Layer ? this._animateZoom : this._animateZoomNoLayer,\n        this\n      );\n    }\n\n    this._reset();\n    return this;\n  }\n\n  onRemove(map: Map): this {\n    if (this.canvas) {\n      const pane = map.getPane(this._pane);\n      if (!pane) {\n        throw new Error(\"unable to find pane\");\n      }\n      pane.removeChild(this.canvas);\n    }\n\n    map.off(\"moveend\", this._reset, this);\n    map.off(\"resize\", this._resize, this);\n\n    if (this.isAnimated()) {\n      map.off(\n        \"zoomanim\",\n        Layer ? this._animateZoom : this._animateZoomNoLayer,\n        this\n      );\n    }\n    return this;\n  }\n\n  addTo(map: Map): this {\n    map.addLayer(this);\n    return this;\n  }\n\n  get map(): Map {\n    return this._map;\n  }\n\n  set map(map: Map) {\n    this._map = map;\n  }\n\n  _resize(resizeEvent: ResizeEvent): void {\n    if (this.canvas) {\n      this.canvas.width = resizeEvent.newSize.x;\n      this.canvas.height = resizeEvent.newSize.y;\n    }\n  }\n\n  _reset(): void {\n    if (this.canvas) {\n      const topLeft = this._map.containerPointToLayerPoint([0, 0]);\n      DomUtil.setPosition(this.canvas, topLeft);\n    }\n    this._redraw();\n  }\n\n  _redraw(): void {\n    const { _map, canvas } = this;\n    const size = _map.getSize();\n    const bounds = _map.getBounds();\n    const zoomScale =\n      (size.x * 180) / (20037508.34 * (bounds.getEast() - bounds.getWest())); // resolution = 1/zoomScale\n    const zoom = _map.getZoom();\n    const topLeft = new LatLng(bounds.getNorth(), bounds.getWest());\n    const offset = this._unclampedProject(topLeft, 0);\n    if (canvas) {\n      this._userDrawFunc({\n        bounds,\n        canvas,\n        offset,\n        scale: Math.pow(2, zoom),\n        size,\n        zoomScale,\n        zoom,\n      });\n    }\n\n    while (this._redrawCallbacks.length > 0) {\n      const callback = this._redrawCallbacks.shift();\n      if (callback) {\n        callback(this);\n      }\n    }\n\n    this._frame = null;\n  }\n\n  _animateZoom(e: ZoomAnimEvent): void {\n    const { _map, canvas } = this;\n    const scale = _map.getZoomScale(e.zoom, _map.getZoom());\n    const offset = this._unclampedLatLngBoundsToNewLayerBounds(\n      _map.getBounds(),\n      e.zoom,\n      e.center\n    ).min;\n    if (canvas && offset) {\n      DomUtil.setTransform(canvas, offset, scale);\n    }\n  }\n\n  _animateZoomNoLayer(e: ZoomAnimEvent): void {\n    const { _map, canvas } = this;\n    if (canvas) {\n      const scale = _map.getZoomScale(e.zoom, _map.getZoom());\n      const offset = _map\n        // @ts-expect-error experimental\n        ._getCenterOffset(e.center)\n        ._multiplyBy(-scale)\n        // @ts-expect-error  experimental\n        .subtract(_map._getMapPanePos());\n      DomUtil.setTransform(canvas, offset, scale);\n    }\n  }\n\n  _unclampedProject(latlng: LatLng, zoom: number): Point {\n    // imported partly from https://github.com/Leaflet/Leaflet/blob/1ae785b73092fdb4b97e30f8789345e9f7c7c912/src/geo/projection/Projection.SphericalMercator.js#L21\n    // used because they clamp the latitude\n    const { crs } = this._map.options;\n    // @ts-expect-error experimental\n    const { R } = crs.projection;\n    const d = Math.PI / 180;\n    const lat = latlng.lat;\n    const sin = Math.sin(lat * d);\n    const projectedPoint = new Point(\n      R * latlng.lng * d,\n      (R * Math.log((1 + sin) / (1 - sin))) / 2\n    );\n    const scale = crs?.scale(zoom) ?? 0;\n    // @ts-expect-error experimental\n    return crs.transformation._transform(projectedPoint, scale);\n  }\n\n  _unclampedLatLngBoundsToNewLayerBounds(\n    latLngBounds: LatLngBounds,\n    zoom: number,\n    center: LatLng\n  ): Bounds {\n    // imported party from https://github.com/Leaflet/Leaflet/blob/84bc05bbb6e4acc41e6f89ff7421dd7c6520d256/src/map/Map.js#L1500\n    // used because it uses crs.projection.project, which clamp the latitude\n    // @ts-expect-error experimental\n    const topLeft = this._map._getNewPixelOrigin(center, zoom);\n    return new Bounds([\n      this._unclampedProject(latLngBounds.getSouthWest(), zoom).subtract(\n        topLeft\n      ),\n      this._unclampedProject(latLngBounds.getNorthWest(), zoom).subtract(\n        topLeft\n      ),\n      this._unclampedProject(latLngBounds.getSouthEast(), zoom).subtract(\n        topLeft\n      ),\n      this._unclampedProject(latLngBounds.getNorthEast(), zoom).subtract(\n        topLeft\n      ),\n    ]);\n  }\n}\n","export function notProperlyDefined(valueName: string): string {\n  return `\"${valueName}\" not properly defined`;\n}\n","export class MapMatrix {\n  array: Float32Array;\n  constructor() {\n    this.array = new Float32Array(16);\n  }\n\n  setSize(width: number, height: number): this {\n    this.array.set([\n      2 / width,\n      0,\n      0,\n      0,\n      0,\n      -2 / height,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      -1,\n      1,\n      0,\n      1,\n    ]);\n    return this;\n  }\n\n  translateTo(x: number, y: number): this {\n    const { array } = this;\n    // translation is in last column of matrix\n    array[12] = array[0] * x - 1;\n    array[13] = array[5] * y + 1;\n    return this;\n  }\n\n  scaleTo(scale: number): this {\n    const { array } = this;\n    // scaling x and y, which is just scaling first two columns of matrix\n    array[0] *= scale;\n    array[5] *= scale;\n    return this;\n  }\n}\n","import { LeafletMouseEvent, Map } from \"leaflet\";\n\nimport { IColor } from \"./color\";\nimport { CanvasOverlay, ICanvasOverlayDrawEvent } from \"./canvas-overlay\";\nimport { notProperlyDefined } from \"./errors\";\nimport { MapMatrix } from \"./map-matrix\";\n\nexport interface IShaderVariable {\n  type: \"FLOAT\";\n  start?: number;\n  size: number;\n  normalize?: boolean;\n}\n\nexport type EventCallback = (\n  e: LeafletMouseEvent,\n  feature: any\n) => boolean | void;\n\nexport type SetupHoverCallback = (map: Map, hoverWait?: number, immediate?: false) => void;\n\nexport interface IBaseGlLayerSettings {\n  data: any;\n  longitudeKey: number;\n  latitudeKey: number;\n  pane: string;\n  map: Map;\n  shaderVariables?: {\n    [name: string]: IShaderVariable;\n  };\n  setupClick?: (map: Map) => void;\n  setupHover?: SetupHoverCallback;\n  sensitivity?: number;\n  sensitivityHover?: number;\n  vertexShaderSource?: (() => string) | string;\n  fragmentShaderSource?: (() => string) | string;\n  canvas?: HTMLCanvasElement;\n  click?: EventCallback;\n  hover?: EventCallback;\n  hoverOff?: EventCallback;\n  color?: ColorCallback | IColor | null;\n  className?: string;\n  opacity?: number;\n  preserveDrawingBuffer?: boolean;\n  hoverWait?: number;\n}\n\nexport const defaultPane = \"overlayPane\";\nexport const defaultHoverWait = 250;\nexport const defaults: Partial<IBaseGlLayerSettings> = {\n  pane: defaultPane,\n};\n\nexport type ColorCallback = (featureIndex: number, feature: any) => IColor;\n\nexport abstract class BaseGlLayer<\n  T extends IBaseGlLayerSettings = IBaseGlLayerSettings\n> {\n  bytes = 0;\n  active: boolean;\n  fragmentShader: any;\n  canvas: HTMLCanvasElement;\n  gl: WebGLRenderingContext | WebGL2RenderingContext;\n  layer: CanvasOverlay;\n  mapMatrix: MapMatrix;\n  matrix: WebGLUniformLocation | null;\n  program: WebGLProgram | null;\n  settings: Partial<IBaseGlLayerSettings>;\n  vertexShader: WebGLShader | null;\n  vertices: any;\n  vertexLines: any;\n\n  buffers: { [name: string]: WebGLBuffer } = {};\n  attributeLocations: { [name: string]: number } = {};\n  uniformLocations: { [name: string]: WebGLUniformLocation } = {};\n\n  static defaults = defaults;\n\n  abstract render(): this;\n\n  get data(): any {\n    if (!this.settings.data) {\n      throw new Error(notProperlyDefined(\"settings.data\"));\n    }\n    return this.settings.data;\n  }\n\n  get pane(): string {\n    return this.settings.pane ?? defaultPane;\n  }\n\n  get className(): string {\n    return this.settings.className ?? \"\";\n  }\n\n  get map(): Map {\n    if (!this.settings.map) {\n      throw new Error(notProperlyDefined(\"settings.map\"));\n    }\n    return this.settings.map;\n  }\n\n  get sensitivity(): number {\n    if (typeof this.settings.sensitivity !== \"number\") {\n      throw new Error(notProperlyDefined(\"settings.sensitivity\"));\n    }\n    return this.settings.sensitivity;\n  }\n\n  get sensitivityHover(): number {\n    if (typeof this.settings.sensitivityHover !== \"number\") {\n      throw new Error(notProperlyDefined(\"settings.sensitivityHover\"));\n    }\n    return this.settings.sensitivityHover;\n  }\n\n  get hoverWait(): number {\n    return this.settings.hoverWait ?? defaultHoverWait;\n  }\n\n  get longitudeKey(): number {\n    if (typeof this.settings.longitudeKey !== \"number\") {\n      throw new Error(notProperlyDefined(\"settings.longitudeKey\"));\n    }\n    return this.settings.longitudeKey;\n  }\n\n  get latitudeKey(): number {\n    if (typeof this.settings.latitudeKey !== \"number\") {\n      throw new Error(notProperlyDefined(\"settings.latitudeKey\"));\n    }\n    return this.settings.latitudeKey;\n  }\n\n  get opacity(): number {\n    if (typeof this.settings.opacity !== \"number\") {\n      throw new Error(notProperlyDefined(\"settings.opacity\"));\n    }\n    return this.settings.opacity;\n  }\n\n  get color(): ColorCallback | IColor | null {\n    return this.settings.color ?? null;\n  }\n\n  constructor(settings: Partial<IBaseGlLayerSettings>) {\n    this.settings = { ...defaults, ...settings };\n    this.mapMatrix = new MapMatrix();\n    this.active = true;\n    this.vertexShader = null;\n    this.fragmentShader = null;\n    this.program = null;\n    this.matrix = null;\n    this.vertices = null;\n    this.vertexLines = null;\n    const preserveDrawingBuffer = Boolean(settings.preserveDrawingBuffer);\n    const layer = (this.layer = new CanvasOverlay(\n      (context: ICanvasOverlayDrawEvent) => {\n        return this.drawOnCanvas(context);\n      },\n      this.pane\n    ).addTo(this.map));\n    if (!layer.canvas) {\n      throw new Error(notProperlyDefined(\"layer.canvas\"));\n    }\n    const canvas = (this.canvas = layer.canvas);\n    canvas.width = canvas.clientWidth;\n    canvas.height = canvas.clientHeight;\n    canvas.style.position = \"absolute\";\n    if (this.className) {\n      canvas.className += \" \" + this.className;\n    }\n    this.gl = (canvas.getContext(\"webgl2\", { preserveDrawingBuffer }) ??\n      canvas.getContext(\"webgl\", { preserveDrawingBuffer }) ??\n      canvas.getContext(\"experimental-webgl\", {\n        preserveDrawingBuffer,\n      })) as WebGLRenderingContext;\n  }\n\n  abstract drawOnCanvas(context: ICanvasOverlayDrawEvent): this;\n\n  attachShaderVariables(byteCount: number): this {\n    const variableCount = this.getShaderVariableCount();\n    if (variableCount === 0) {\n      return this;\n    }\n    const { gl, settings } = this;\n    const { shaderVariables } = settings;\n    let offset = 0;\n    for (const name in shaderVariables) {\n      if (!shaderVariables.hasOwnProperty(name)) continue;\n      const shaderVariable = shaderVariables[name];\n      const loc = this.getAttributeLocation(name);\n      if (loc < 0) {\n        throw new Error(\"shader variable \" + name + \" not found\");\n      }\n      gl.vertexAttribPointer(\n        loc,\n        shaderVariable.size,\n        gl[shaderVariable.type],\n        !!shaderVariable.normalize,\n        this.bytes * byteCount,\n        offset * byteCount\n      );\n      offset += shaderVariable.size;\n      gl.enableVertexAttribArray(loc);\n    }\n\n    return this;\n  }\n\n  getShaderVariableCount(): number {\n    return Object.keys(this.settings.shaderVariables ?? {}).length;\n  }\n\n  setData(data: any): this {\n    this.settings = { ...this.settings, data };\n    return this.render();\n  }\n\n  setup(): this {\n    const settings = this.settings;\n    if (settings.click && settings.setupClick) {\n      settings.setupClick(this.map);\n    }\n    if (settings.hover && settings.setupHover) {\n      settings.setupHover(this.map, this.hoverWait);\n    }\n\n    return this.setupVertexShader().setupFragmentShader().setupProgram();\n  }\n\n  setupVertexShader(): this {\n    const { gl, settings } = this;\n    const vertexShaderSource =\n      typeof settings.vertexShaderSource === \"function\"\n        ? settings.vertexShaderSource()\n        : settings.vertexShaderSource;\n    const vertexShader = gl.createShader(gl.VERTEX_SHADER);\n    if (!vertexShader) {\n      throw new Error(\"Not able to create vertex\");\n    }\n    if (!vertexShaderSource) {\n      throw new Error(notProperlyDefined(\"settings.vertexShaderSource\"));\n    }\n    gl.shaderSource(vertexShader, vertexShaderSource);\n    gl.compileShader(vertexShader);\n\n    this.vertexShader = vertexShader;\n\n    return this;\n  }\n\n  setupFragmentShader(): this {\n    const gl = this.gl;\n    const settings = this.settings;\n    const fragmentShaderSource =\n      typeof settings.fragmentShaderSource === \"function\"\n        ? settings.fragmentShaderSource()\n        : settings.fragmentShaderSource;\n    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n    if (!fragmentShader) {\n      throw new Error(\"Not able to create fragment\");\n    }\n    if (!fragmentShaderSource) {\n      throw new Error(notProperlyDefined(\"settings.fragmentShaderSource\"));\n    }\n    gl.shaderSource(fragmentShader, fragmentShaderSource);\n    gl.compileShader(fragmentShader);\n\n    this.fragmentShader = fragmentShader;\n\n    return this;\n  }\n\n  setupProgram(): this {\n    // link shaders to create our program\n    const { gl, vertexShader, fragmentShader } = this;\n    const program = gl.createProgram();\n    if (!program) {\n      throw new Error(\"Not able to create program\");\n    }\n    if (!vertexShader) {\n      throw new Error(notProperlyDefined(\"this.vertexShader\"));\n    }\n    if (!fragmentShader) {\n      throw new Error(notProperlyDefined(\"this.fragmentShader\"));\n    }\n\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    gl.linkProgram(program);\n    gl.useProgram(program);\n    gl.blendFuncSeparate(\n      gl.SRC_ALPHA,\n      gl.ONE_MINUS_SRC_ALPHA,\n      gl.ONE,\n      gl.ONE_MINUS_SRC_ALPHA\n    );\n    gl.enable(gl.BLEND);\n\n    this.program = program;\n\n    return this;\n  }\n\n  addTo(map?: Map): this {\n    this.layer.addTo(map ?? this.map);\n    this.active = true;\n    return this.render();\n  }\n\n  remove(indices?: number | number[]): this {\n    if (indices === undefined) {\n      this.map.removeLayer(this.layer);\n      this.active = false;\n    } else {\n      const features = this.settings.data.features || this.settings.data;\n      indices = indices instanceof Array ? indices : [indices];\n      if (typeof indices === \"number\") {\n        indices = [indices];\n      }\n      indices\n        .sort((a: number, b: number): number => {\n          return a - b;\n        })\n        .reverse()\n        .forEach((index: number) => {\n          features.splice(index, 1);\n        });\n      this.render();\n    }\n    return this;\n  }\n\n  insert(feature: any, index: number): this {\n    const features = this.settings.data.features || this.settings.data;\n    features.splice(index, 0, feature);\n    return this.render();\n  }\n\n  update(feature: any, index: number): this {\n    const features = this.settings.data.features || this.settings.data;\n    features[index] = feature;\n    return this.render();\n  }\n\n  getBuffer(name: string): WebGLBuffer {\n    if (!this.buffers[name]) {\n      const buffer = this.gl.createBuffer();\n      if (!buffer) {\n        throw new Error(\"Not able to create buffer\");\n      }\n      this.buffers[name] = buffer;\n    }\n    return this.buffers[name];\n  }\n\n  getAttributeLocation(name: string): number {\n    if (!this.program) {\n      throw new Error(notProperlyDefined(\"this.program\"));\n    }\n    if (this.attributeLocations[name] !== undefined) {\n      return this.attributeLocations[name];\n    }\n    return (this.attributeLocations[name] = this.gl.getAttribLocation(\n      this.program,\n      name\n    ));\n  }\n\n  getUniformLocation(name: string): WebGLUniformLocation {\n    if (!this.program) {\n      throw new Error(notProperlyDefined(\"this.program\"));\n    }\n    if (this.uniformLocations[name] !== undefined) {\n      return this.uniformLocations[name];\n    }\n    const loc = this.gl.getUniformLocation(this.program, name);\n    if (!loc) {\n      throw new Error(\"Cannot find location\");\n    }\n    return (this.uniformLocations[name] = loc);\n  }\n\n  click(e: LeafletMouseEvent, feature: any): boolean | undefined {\n    if (!this.settings.click) return;\n    const result = this.settings.click(e, feature);\n    if (result !== undefined) {\n      return result;\n    }\n  }\n\n  hover(e: LeafletMouseEvent, feature: any): boolean | undefined {\n    if (!this.settings.hover) return;\n    const result = this.settings.hover(e, feature);\n    if (result !== undefined) {\n      return result;\n    }\n  }\n\n  hoverOff(e: LeafletMouseEvent, feature: any): void {\n    if (!this.settings.hoverOff) return;\n    this.settings.hoverOff(e, feature);\n  }\n}\n","export interface IColor {\n  r: number;\n  g: number;\n  b: number;\n  a?: number;\n}\n\nexport const green: IColor = { r: 0, g: 1, b: 0, a: 1 };\nexport const red: IColor = { r: 1, g: 0, b: 0, a: 1 };\nexport const blue: IColor = { r: 0, g: 0, b: 1, a: 1 };\nexport const teal: IColor = { r: 0, g: 1, b: 1, a: 1 };\nexport const yellow: IColor = { r: 1, g: 1, b: 0, a: 1 };\n\nexport const white: IColor = { r: 1, g: 1, b: 1, a: 1 };\nexport const black: IColor = { r: 0, g: 0, b: 0, a: 1 };\n\nexport const gray: IColor = { r: 0.5, g: 0.5, b: 0.5, a: 1 };\nexport const grey = gray;\n\nexport function fromHex(hex: string): IColor | null {\n  if (hex.length < 6) return null;\n  hex = hex.toLowerCase();\n\n  if (hex[0] === \"#\") {\n    hex = hex.substring(1, hex.length);\n  }\n\n  const r = parseInt(hex[0] + hex[1], 16);\n  const g = parseInt(hex[2] + hex[3], 16);\n  const b = parseInt(hex[4] + hex[5], 16);\n  return { r: r / 255, g: g / 255, b: b / 255, a: 1 };\n}\n\nexport function random(): IColor {\n  return {\n    r: Math.random(),\n    g: Math.random(),\n    b: Math.random(),\n    a: Math.random(),\n  };\n}\n\nexport function pallet(): IColor {\n  switch (Math.round(Math.random() * 4)) {\n    case 0:\n      return green;\n    case 1:\n      return red;\n    case 2:\n      return blue;\n    case 3:\n      return teal;\n    case 4:\n    default:\n      return yellow;\n  }\n}\n","import { LatLng } from \"leaflet\";\nimport { Position } from \"geojson\";\nimport { IColor } from \"./color\";\nimport { IPixel } from \"./pixel\";\n\ninterface ILineFeatureVerticesSettings {\n  project: (coordinates: LatLng, distance: number) => IPixel;\n  color: IColor;\n  weight: number;\n  latitudeKey: number;\n  longitudeKey: number;\n  opacity: number;\n}\n\nexport class LineFeatureVertices {\n  settings: ILineFeatureVerticesSettings;\n  vertexCount: number;\n  array: number[];\n  pixels: IPixel[] = [];\n  latLngs: LatLng[] = [];\n  get length(): number {\n    return this.array.length;\n  }\n\n  constructor(settings: ILineFeatureVerticesSettings) {\n    this.settings = settings;\n    this.vertexCount = 0;\n    this.array = [];\n  }\n\n  fillFromCoordinates(coordinates: Position[] | Position[][]): void {\n    const {\n      color,\n      opacity,\n      project,\n      latitudeKey,\n      longitudeKey,\n    } = this.settings;\n    for (let i = 0; i < coordinates.length; i++) {\n      if (Array.isArray(coordinates[i][0])) {\n        this.fillFromCoordinates(coordinates[i] as Position[]);\n        continue;\n      }\n      const flatterCoordinates: Position[] = coordinates as Position[];\n      const latLng = new LatLng(\n        flatterCoordinates[i][latitudeKey],\n        flatterCoordinates[i][longitudeKey]\n      );\n      this.latLngs.push(latLng);\n      const pixel = project(latLng, 0);\n      this.pixels.push(pixel);\n      this.push(\n        pixel.x,\n        pixel.y,\n        color.r,\n        color.g,\n        color.b,\n        color.a ?? opacity\n      );\n      if (i !== 0 && i !== coordinates.length - 1) {\n        this.vertexCount += 1;\n      }\n      this.vertexCount += 1;\n    }\n  }\n\n  push(...args: number[]) {\n    this.array.push(...args);\n  }\n}\n","import { LatLng, LatLngBounds, LeafletMouseEvent, Map } from \"leaflet\";\nimport { IPixel } from \"./pixel\";\n\n// -- converts latlon to pixels at zoom level 0 (for 256x256 tile size) , inverts y coord )\n// -- source : http://build-failed.blogspot.cz/2013/02/displaying-webgl-data-on-google-maps.html\nexport function latLonToPixel(latitude: number, longitude: number): IPixel {\n  const pi180 = Math.PI / 180.0;\n  const pi4 = Math.PI * 4;\n  const sinLatitude = Math.sin(latitude * pi180);\n  const pixelY =\n    (0.5 - Math.log((1 + sinLatitude) / (1 - sinLatitude)) / pi4) * 256;\n  const pixelX = ((longitude + 180) / 360) * 256;\n\n  return { x: pixelX, y: pixelY };\n}\n\nexport function pixelInCircle(\n  centerPixel: IPixel,\n  checkPoint: IPixel,\n  radius: number\n): boolean {\n  const distanceSquared =\n    (centerPixel.x - checkPoint.x) * (centerPixel.x - checkPoint.x) +\n    (centerPixel.y - checkPoint.y) * (centerPixel.y - checkPoint.y);\n  return distanceSquared <= radius * radius;\n}\n\nexport function latLngDistance(\n  x: number,\n  y: number,\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number\n): number {\n  const A = x - x1;\n  const B = y - y1;\n  const C = x2 - x1;\n  const D = y2 - y1;\n\n  const dot = A * C + B * D;\n  const lenSq = C * C + D * D;\n  let param = -1;\n  if (lenSq !== 0) {\n    // in case of 0 length line\n    param = dot / lenSq;\n  }\n\n  let xx, yy;\n\n  if (param < 0) {\n    xx = x1;\n    yy = y1;\n  } else if (param > 1) {\n    xx = x2;\n    yy = y2;\n  } else {\n    xx = x1 + param * C;\n    yy = y1 + param * D;\n  }\n\n  const dx = x - xx;\n  const dy = y - yy;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nexport function vectorDistance(dx: number, dy: number): number {\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nexport function locationDistance(\n  location1: LatLng,\n  location2: LatLng,\n  map: Map\n): number {\n  const point1 = map.latLngToLayerPoint(location1);\n  const point2 = map.latLngToLayerPoint(location2);\n  const dx = point1.x - point2.x;\n  const dy = point1.y - point2.y;\n  return vectorDistance(dx, dy);\n}\n\nexport function debugPoint(containerPixel: IPixel): void {\n  const el = document.createElement(\"div\");\n  const s = el.style;\n  const x = containerPixel.x;\n  const y = containerPixel.y;\n  s.left = `${x}px`;\n  s.top = `${y}px`;\n  s.width = \"10px\";\n  s.height = \"10px\";\n  s.position = \"absolute\";\n  s.backgroundColor = \"#\" + ((Math.random() * 0xffffff) << 0).toString(16);\n\n  document.body.appendChild(el);\n}\n\nexport function debounce(\n  fn: (e: LeafletMouseEvent) => void,\n  waitMilliseconds: number,\n  immediate?: boolean\n): (e: LeafletMouseEvent) => void {\n  let timeout: ReturnType<typeof setTimeout> | null = null;\n  return function (e: LeafletMouseEvent): void {\n    function later() {\n      timeout = null;\n      if (!immediate) fn(e);\n    }\n    const callNow = immediate && !timeout;\n    if (timeout !== null) {\n      clearTimeout(timeout);\n    }\n    timeout = setTimeout(later, waitMilliseconds);\n    if (callNow) fn(e);\n  };\n}\n\nexport function inBounds(latLng: LatLng, bounds: LatLngBounds): boolean {\n  const ne = bounds.getNorthEast();\n  const sw = bounds.getSouthWest();\n  return (\n    ne.lat > latLng.lat &&\n    latLng.lat > sw.lat &&\n    ne.lng > latLng.lng &&\n    latLng.lng > sw.lng\n  );\n}\n","import { Map, LeafletMouseEvent, geoJSON } from \"leaflet\";\nimport {\n  Feature,\n  FeatureCollection,\n  LineString,\n  MultiLineString,\n  Position,\n} from \"geojson\";\n\nimport {\n  BaseGlLayer,\n  ColorCallback,\n  IBaseGlLayerSettings,\n} from \"./base-gl-layer\";\nimport { ICanvasOverlayDrawEvent } from \"./canvas-overlay\";\nimport * as color from \"./color\";\nimport { LineFeatureVertices } from \"./line-feature-vertices\";\nimport { latLngDistance, inBounds } from \"./utils\";\n\nexport type WeightCallback = (i: number, feature: any) => number;\n\nexport interface ILinesSettings extends IBaseGlLayerSettings {\n  data: FeatureCollection<LineString | MultiLineString>;\n  weight: WeightCallback | number;\n  sensitivity?: number;\n  sensitivityHover?: number;\n  eachVertex?: (vertices: LineFeatureVertices) => void;\n}\n\nconst defaults: Partial<ILinesSettings> = {\n  data: {\n    type: \"FeatureCollection\",\n    features: [],\n  },\n  color: color.random,\n  className: \"\",\n  opacity: 0.5,\n  weight: 2,\n  sensitivity: 0.1,\n  sensitivityHover: 0.03,\n  shaderVariables: {\n    vertex: {\n      type: \"FLOAT\",\n      start: 0,\n      size: 2,\n    },\n    color: {\n      type: \"FLOAT\",\n      start: 2,\n      size: 4,\n    },\n  },\n};\n\nexport class Lines extends BaseGlLayer<ILinesSettings> {\n  static defaults = defaults;\n\n  scale = Infinity;\n  bytes = 6;\n  allVertices: number[] = [];\n  allVerticesTyped: Float32Array = new Float32Array(0);\n  vertices: LineFeatureVertices[] = [];\n  aPointSize = -1;\n  settings: Partial<ILinesSettings>;\n\n  get weight(): WeightCallback | number {\n    if (!this.settings.weight) {\n      throw new Error(\"settings.weight not correctly defined\");\n    }\n    return this.settings.weight;\n  }\n\n  constructor(settings: Partial<ILinesSettings>) {\n    super(settings);\n    this.settings = { ...Lines.defaults, ...settings };\n\n    if (!settings.data) {\n      throw new Error('\"data\" is missing');\n    }\n    this.active = true;\n    this.setup().render();\n  }\n\n  render(): this {\n    this.resetVertices();\n\n    const { canvas, gl, layer, mapMatrix } = this;\n    const vertexBuffer = this.getBuffer(\"vertex\");\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n\n    const size = this.allVerticesTyped.BYTES_PER_ELEMENT;\n    gl.bufferData(gl.ARRAY_BUFFER, this.allVerticesTyped, gl.STATIC_DRAW);\n    const vertexLocation = this.getAttributeLocation(\"vertex\");\n    gl.vertexAttribPointer(\n      vertexLocation,\n      2,\n      gl.FLOAT,\n      false,\n      size * this.bytes,\n      0\n    );\n    gl.enableVertexAttribArray(vertexLocation);\n\n    //  gl.disable(gl.DEPTH_TEST);\n    // ----------------------------\n    // look up the locations for the inputs to our shaders.\n    this.matrix = this.getUniformLocation(\"matrix\");\n    this.aPointSize = this.getAttributeLocation(\"pointSize\");\n\n    // Set the matrix to some that makes 1 unit 1 pixel.\n    mapMatrix.setSize(canvas.width, canvas.height);\n    gl.viewport(0, 0, canvas.width, canvas.height);\n\n    gl.uniformMatrix4fv(this.matrix, false, mapMatrix.array);\n\n    this.attachShaderVariables(size);\n\n    layer.redraw();\n\n    return this;\n  }\n\n  resetVertices(): this {\n    const {\n      map,\n      opacity,\n      color,\n      weight,\n      latitudeKey,\n      longitudeKey,\n      data,\n      bytes,\n      settings,\n    } = this;\n    const { eachVertex } = settings;\n    const { features } = data;\n    const featureMax = features.length;\n    let feature: Feature<LineString | MultiLineString>;\n    let colorFn: ColorCallback | null = null;\n    let weightFn: WeightCallback | null = null;\n    let chosenColor: color.IColor;\n    let featureIndex = 0;\n\n    if (typeof color === \"function\") {\n      colorFn = color;\n    }\n    if (typeof weight === \"function\") {\n      weightFn = weight;\n    }\n\n    const project = map.project.bind(map);\n    // -- data\n    const vertices: LineFeatureVertices[] = [];\n    for (; featureIndex < featureMax; featureIndex++) {\n      feature = features[featureIndex];\n      // use colorFn function here if it exists\n      if (colorFn) {\n        chosenColor = colorFn(featureIndex, feature);\n      } else {\n        chosenColor = color as color.IColor;\n      }\n\n      const chosenWeight: number = weightFn\n        ? weightFn(featureIndex, feature)\n        : (weight as number);\n\n      const featureVertices = new LineFeatureVertices({\n        project,\n        latitudeKey,\n        longitudeKey,\n        color: chosenColor,\n        weight: chosenWeight,\n        opacity,\n      });\n\n      featureVertices.fillFromCoordinates(feature.geometry.coordinates);\n      vertices.push(featureVertices);\n      if (eachVertex) {\n        eachVertex(featureVertices);\n      }\n    }\n\n    /*\n    Transforming lines according to the rule:\n    1. Take one line (single feature)\n    [[0,0],[1,1],[2,2]]\n    2. Split the line in segments, duplicating all coordinates except first and last one\n    [[0,0],[1,1],[2,2]] => [[0,0],[1,1],[1,1],[2,2]]\n    3. Do this for all lines and put all coordinates in array\n    */\n    const size = vertices.length;\n    const allVertices = [];\n    for (let i = 0; i < size; i++) {\n      const vertexArray = vertices[i].array;\n      const length = vertexArray.length / bytes;\n      for (let j = 0; j < length; j++) {\n        const vertexIndex = j * bytes;\n        if (j !== 0 && j !== length - 1) {\n          allVertices.push(\n            vertexArray[vertexIndex],\n            vertexArray[vertexIndex + 1],\n            vertexArray[vertexIndex + 2],\n            vertexArray[vertexIndex + 3],\n            vertexArray[vertexIndex + 4],\n            vertexArray[vertexIndex + 5]\n          );\n        }\n        allVertices.push(\n          vertexArray[vertexIndex],\n          vertexArray[vertexIndex + 1],\n          vertexArray[vertexIndex + 2],\n          vertexArray[vertexIndex + 3],\n          vertexArray[vertexIndex + 4],\n          vertexArray[vertexIndex + 5]\n        );\n      }\n    }\n\n    this.vertices = vertices;\n    this.allVertices = allVertices;\n    this.allVerticesTyped = new Float32Array(allVertices);\n\n    return this;\n  }\n\n  drawOnCanvas(e: ICanvasOverlayDrawEvent): this {\n    if (!this.gl) return this;\n\n    const {\n      gl,\n      data,\n      canvas,\n      mapMatrix,\n      matrix,\n      allVertices,\n      vertices,\n      weight,\n      aPointSize,\n      bytes,\n    } = this;\n    const { scale, offset, zoom } = e;\n    this.scale = scale;\n    const pointSize = Math.max(zoom - 4.0, 4.0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    gl.viewport(0, 0, canvas.width, canvas.height);\n    gl.vertexAttrib1f(aPointSize, pointSize);\n    mapMatrix.setSize(canvas.width, canvas.height).scaleTo(scale);\n    if (zoom > 18) {\n      mapMatrix.translateTo(-offset.x, -offset.y);\n      // -- attach matrix value to 'mapMatrix' uniform in shader\n      gl.uniformMatrix4fv(matrix, false, mapMatrix.array);\n\n      gl.drawArrays(gl.LINES, 0, allVertices.length / bytes);\n    } else if (typeof weight === \"number\") {\n      // Now draw the lines several times, but like a brush, taking advantage of the half pixel line generally used by cards\n      for (let yOffset = -weight; yOffset <= weight; yOffset += 0.5) {\n        for (let xOffset = -weight; xOffset <= weight; xOffset += 0.5) {\n          // -- set base matrix to translate canvas pixel coordinates -> webgl coordinates\n          mapMatrix.translateTo(\n            -offset.x + xOffset / scale,\n            -offset.y + yOffset / scale\n          );\n          // -- attach matrix value to 'mapMatrix' uniform in shader\n          gl.uniformMatrix4fv(matrix, false, mapMatrix.array);\n\n          gl.drawArrays(gl.LINES, 0, allVertices.length / bytes);\n        }\n      }\n    } else if (typeof weight === \"function\") {\n      let allVertexCount = 0;\n      const { features } = data;\n      for (let i = 0; i < vertices.length; i++) {\n        const featureVertices = vertices[i];\n        const { vertexCount } = featureVertices;\n        const weightValue = weight(i, features[i]);\n        // Now draw the lines several times, but like a brush, taking advantage of the half pixel line generally used by cards\n        for (\n          let yOffset = -weightValue;\n          yOffset <= weightValue;\n          yOffset += 0.5\n        ) {\n          for (\n            let xOffset = -weightValue;\n            xOffset <= weightValue;\n            xOffset += 0.5\n          ) {\n            // -- set base matrix to translate canvas pixel coordinates -> webgl coordinates\n            mapMatrix.translateTo(\n              -offset.x + xOffset / scale,\n              -offset.y + yOffset / scale\n            );\n            // -- attach matrix value to 'mapMatrix' uniform in shader\n            gl.uniformMatrix4fv(this.matrix, false, mapMatrix.array);\n\n            gl.drawArrays(gl.LINES, allVertexCount, vertexCount);\n          }\n        }\n        allVertexCount += vertexCount;\n      }\n    }\n    return this;\n  }\n\n  // attempts to click the top-most Lines instance\n  static tryClick(\n    e: LeafletMouseEvent,\n    map: Map,\n    instances: Lines[]\n  ): boolean | undefined {\n    let foundFeature: Feature<LineString | MultiLineString> | null = null;\n    let foundLines: Lines | null = null;\n\n    instances.forEach((instance: Lines): void => {\n      const {\n        latitudeKey,\n        longitudeKey,\n        sensitivity,\n        weight,\n        scale,\n        active,\n      } = instance;\n      if (!active) return;\n      if (instance.map !== map) return;\n      function checkClick(\n        coordinate: Position,\n        prevCoordinate: Position,\n        feature: Feature<LineString | MultiLineString>,\n        chosenWeight: number\n      ): void {\n        const distance = latLngDistance(\n          e.latlng.lng,\n          e.latlng.lat,\n          prevCoordinate[longitudeKey],\n          prevCoordinate[latitudeKey],\n          coordinate[longitudeKey],\n          coordinate[latitudeKey]\n        );\n        if (distance <= sensitivity + chosenWeight / scale) {\n          foundFeature = feature;\n          foundLines = instance;\n        }\n      }\n      instance.data.features.forEach(\n        (feature: Feature<LineString | MultiLineString>, i: number): void => {\n          const chosenWeight =\n            typeof weight === \"function\" ? weight(i, feature) : weight;\n          const { coordinates, type } = feature.geometry;\n          if (type === \"LineString\") {\n            for (let i = 1; i < coordinates.length; i++) {\n              checkClick(\n                coordinates[i] as Position,\n                coordinates[i - 1] as Position,\n                feature,\n                chosenWeight\n              );\n            }\n          } else if (type === \"MultiLineString\") {\n            // TODO: Unit test\n            for (let i = 0; i < coordinates.length; i++) {\n              const coordinate = coordinates[i];\n              for (let j = 0; j < coordinate.length; j++) {\n                if (j === 0 && i > 0) {\n                  const prevCoordinates = coordinates[i - 1];\n                  const lastPositions =\n                    prevCoordinates[prevCoordinates.length - 1];\n                  checkClick(\n                    lastPositions as Position,\n                    coordinates[i][j] as Position,\n                    feature,\n                    chosenWeight\n                  );\n                } else if (j > 0) {\n                  checkClick(\n                    coordinates[i][j] as Position,\n                    coordinates[i][j - 1] as Position,\n                    feature,\n                    chosenWeight\n                  );\n                }\n              }\n            }\n          }\n        }\n      );\n    });\n\n    if (foundLines && foundFeature) {\n      const result = (foundLines as Lines).click(e, foundFeature);\n      return result !== undefined ? result : undefined;\n    }\n  }\n\n  hoveringFeatures: Array<Feature<LineString | MultiLineString>> = [];\n  // hovers all touching Lines instances\n  static tryHover(\n    e: LeafletMouseEvent,\n    map: Map,\n    instances: Lines[]\n  ): Array<boolean | undefined> {\n    const results: Array<boolean | undefined> = [];\n    instances.forEach((instance: Lines): void => {\n      const {\n        sensitivityHover,\n        latitudeKey,\n        longitudeKey,\n        data,\n        hoveringFeatures,\n        weight,\n        scale,\n      } = instance;\n      function checkHover(\n        coordinate: Position,\n        prevCoordinate: Position,\n        feature: Feature<LineString | MultiLineString>,\n        chosenWeight: number\n      ): boolean {\n        const distance = latLngDistance(\n          e.latlng.lng,\n          e.latlng.lat,\n          prevCoordinate[longitudeKey],\n          prevCoordinate[latitudeKey],\n          coordinate[longitudeKey],\n          coordinate[latitudeKey]\n        );\n\n        if (distance <= sensitivityHover + chosenWeight / scale) {\n          if (!newHoveredFeatures.includes(feature)) {\n            newHoveredFeatures.push(feature);\n          }\n          if (!oldHoveredFeatures.includes(feature)) {\n            return true;\n          }\n        }\n        return false;\n      }\n      if (!instance.active) return;\n      if (map !== instance.map) return;\n      const oldHoveredFeatures = hoveringFeatures;\n      const newHoveredFeatures: Array<\n        Feature<LineString | MultiLineString>\n      > = [];\n      instance.hoveringFeatures = newHoveredFeatures;\n      // Check if e.latlng is inside the bbox of the features\n      const bounds = geoJSON(data.features).getBounds();\n\n      if (inBounds(e.latlng, bounds)) {\n        data.features.forEach(\n          (feature: Feature<LineString | MultiLineString>, i: number): void => {\n            const chosenWeight =\n              typeof weight === \"function\" ? weight(i, feature) : weight;\n            const { coordinates, type } = feature.geometry;\n            let isHovering = false;\n            if (type === \"LineString\") {\n              for (let i = 1; i < coordinates.length; i++) {\n                isHovering = checkHover(\n                  coordinates[i] as Position,\n                  coordinates[i - 1] as Position,\n                  feature,\n                  chosenWeight\n                );\n                if (isHovering) break;\n              }\n            } else if (type === \"MultiLineString\") {\n              // TODO: Unit test\n              for (let i = 0; i < coordinates.length; i++) {\n                const coordinate = coordinates[i];\n                for (let j = 0; j < coordinate.length; j++) {\n                  if (j === 0 && i > 0) {\n                    const prevCoordinates = coordinates[i - 1];\n                    const lastPositions =\n                      prevCoordinates[prevCoordinates.length - 1];\n                    isHovering = checkHover(\n                      lastPositions as Position,\n                      coordinates[i][j] as Position,\n                      feature,\n                      chosenWeight\n                    );\n                    if (isHovering) break;\n                  } else if (j > 0) {\n                    isHovering = checkHover(\n                      coordinates[i][j] as Position,\n                      coordinates[i][j - 1] as Position,\n                      feature,\n                      chosenWeight\n                    );\n                    if (isHovering) break;\n                  }\n                }\n              }\n            }\n            if (isHovering) {\n              const result = instance.hover(e, feature);\n              if (result !== undefined) {\n                results.push(result);\n              }\n            }\n          }\n        );\n      }\n      for (let i = 0; i < oldHoveredFeatures.length; i++) {\n        const feature = oldHoveredFeatures[i];\n        if (!newHoveredFeatures.includes(feature)) {\n          instance.hoverOff(e, feature);\n        }\n      }\n    });\n    return results;\n  }\n}\n","import {\n  Feature,\n  FeatureCollection,\n  Point as GeoPoint,\n  Position,\n} from \"geojson\";\n\nimport { BaseGlLayer, IBaseGlLayerSettings } from \"./base-gl-layer\";\nimport { ICanvasOverlayDrawEvent } from \"./canvas-overlay\";\nimport * as Color from \"./color\";\nimport { LeafletMouseEvent, Map, Point, LatLng } from \"leaflet\";\nimport { IPixel } from \"./pixel\";\nimport { locationDistance, pixelInCircle } from \"./utils\";\n\nexport interface IPointsSettings extends IBaseGlLayerSettings {\n  data: number[][] | FeatureCollection<GeoPoint>;\n  size?: ((i: number, latLng: LatLng | null) => number) | number | null;\n  eachVertex?: (pointVertex: IPointVertex) => void;\n  sensitivity?: number;\n  sensitivityHover?: number;\n}\n\nconst defaults: Partial<IPointsSettings> = {\n  color: Color.random,\n  opacity: 0.8,\n  className: \"\",\n  sensitivity: 2,\n  sensitivityHover: 0.03,\n  shaderVariables: {\n    vertex: {\n      type: \"FLOAT\",\n      start: 0,\n      size: 2,\n    },\n    color: {\n      type: \"FLOAT\",\n      start: 2,\n      size: 4,\n    },\n    pointSize: {\n      type: \"FLOAT\",\n      start: 6,\n      size: 1,\n    },\n  },\n};\n\nexport interface IPointVertex {\n  latLng: LatLng;\n  pixel: IPixel;\n  chosenColor: Color.IColor;\n  chosenSize: number;\n  key: string;\n  feature?: any;\n}\n\nexport class Points extends BaseGlLayer<IPointsSettings> {\n  static defaults = defaults;\n  static maps = [];\n  bytes = 7;\n  latLngLookup: {\n    [key: string]: IPointVertex[];\n  } = {};\n\n  allLatLngLookup: IPointVertex[] = [];\n  vertices: number[] = [];\n  typedVertices: Float32Array = new Float32Array();\n  dataFormat: \"Array\" | \"GeoJson.FeatureCollection\";\n  settings: Partial<IPointsSettings>;\n  active: boolean;\n\n  get size(): ((i: number, latLng: LatLng | null) => number) | number | null {\n    if (typeof this.settings.size === \"number\") {\n      return this.settings.size;\n    }\n    if (typeof this.settings.size === \"function\") {\n      return this.settings.size;\n    }\n    return null;\n  }\n\n  constructor(settings: Partial<IPointsSettings>) {\n    super(settings);\n    this.settings = { ...defaults, ...settings };\n\n    this.active = true;\n\n    const { data, map } = this;\n    if (Array.isArray(data)) {\n      this.dataFormat = \"Array\";\n    } else if (data.type === \"FeatureCollection\") {\n      this.dataFormat = \"GeoJson.FeatureCollection\";\n    } else {\n      throw new Error(\n        \"unhandled data type. Supported types are Array and GeoJson.FeatureCollection\"\n      );\n    }\n\n    if (map.options.crs?.code !== \"EPSG:3857\") {\n      console.warn(\"layer designed for SphericalMercator, alternate detected\");\n    }\n\n    this.setup().render();\n  }\n\n  render(): this {\n    this.resetVertices();\n\n    // look up the locations for the inputs to our shaders.\n    const { gl, canvas, layer, vertices, mapMatrix } = this;\n    const matrix = (this.matrix = this.getUniformLocation(\"matrix\"));\n    const verticesBuffer = this.getBuffer(\"vertices\");\n    const verticesTyped = (this.typedVertices = new Float32Array(vertices));\n    const byteCount = verticesTyped.BYTES_PER_ELEMENT;\n    // set the matrix to some that makes 1 unit 1 pixel.\n    mapMatrix.setSize(canvas.width, canvas.height);\n    gl.viewport(0, 0, canvas.width, canvas.height);\n    gl.uniformMatrix4fv(matrix, false, mapMatrix.array);\n    gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, verticesTyped, gl.STATIC_DRAW);\n\n    this.attachShaderVariables(byteCount);\n\n    layer.redraw();\n\n    return this;\n  }\n\n  getPointLookup(key: string): IPointVertex[] {\n    return this.latLngLookup[key] || (this.latLngLookup[key] = []);\n  }\n\n  addLookup(lookup: IPointVertex): this {\n    this.getPointLookup(lookup.key).push(lookup);\n    this.allLatLngLookup.push(lookup);\n    return this;\n  }\n\n  resetVertices(): this {\n    // empty vertices and repopulate\n    this.latLngLookup = {};\n    this.allLatLngLookup = [];\n    this.vertices = [];\n\n    const {\n      vertices,\n      settings,\n      map,\n      size,\n      latitudeKey,\n      longitudeKey,\n      color,\n      opacity,\n      data,\n    } = this;\n    const { eachVertex } = settings;\n    let colorFn:\n      | ((i: number, latLng: LatLng | any) => Color.IColor)\n      | null = null;\n    let chosenColor: Color.IColor;\n    let chosenSize: number;\n    let sizeFn;\n    let rawLatLng: [number, number] | Position;\n    let latLng: LatLng;\n    let pixel: Point;\n    let key;\n\n    if (!color) {\n      throw new Error(\"color is not properly defined\");\n    } else if (typeof color === \"function\") {\n      colorFn = color as (i: number, latLng: LatLng) => Color.IColor;\n    }\n\n    if (!size) {\n      throw new Error(\"size is not properly defined\");\n    } else if (typeof size === \"function\") {\n      sizeFn = size;\n    }\n\n    if (this.dataFormat === \"Array\") {\n      const max = data.length;\n      for (let i = 0; i < max; i++) {\n        rawLatLng = data[i];\n        key =\n          rawLatLng[latitudeKey].toFixed(2) +\n          \"x\" +\n          rawLatLng[longitudeKey].toFixed(2);\n        latLng = new LatLng(rawLatLng[latitudeKey], rawLatLng[longitudeKey]);\n        pixel = map.project(latLng, 0);\n\n        if (colorFn) {\n          chosenColor = colorFn(i, latLng);\n        } else {\n          chosenColor = color as Color.IColor;\n        }\n\n        chosenColor = { ...chosenColor, a: chosenColor.a ?? opacity ?? 0 };\n\n        if (sizeFn) {\n          chosenSize = sizeFn(i, latLng);\n        } else {\n          chosenSize = size as number;\n        }\n\n        vertices.push(\n          // vertex\n          pixel.x,\n          pixel.y,\n\n          // color\n          chosenColor.r,\n          chosenColor.g,\n          chosenColor.b,\n          chosenColor.a ?? 0,\n\n          // size\n          chosenSize\n        );\n        const vertex = {\n          latLng,\n          key,\n          pixel,\n          chosenColor,\n          chosenSize,\n          feature: rawLatLng,\n        };\n        this.addLookup(vertex);\n        if (eachVertex) {\n          eachVertex(vertex);\n        }\n      }\n    } else if (this.dataFormat === \"GeoJson.FeatureCollection\") {\n      const max = data.features.length;\n      for (let i = 0; i < max; i++) {\n        const feature = data.features[i] as Feature<GeoPoint>;\n        rawLatLng = feature.geometry.coordinates;\n        key =\n          rawLatLng[latitudeKey].toFixed(2) +\n          \"x\" +\n          rawLatLng[longitudeKey].toFixed(2);\n        latLng = new LatLng(rawLatLng[latitudeKey], rawLatLng[longitudeKey]);\n        pixel = map.project(latLng, 0);\n\n        if (colorFn) {\n          chosenColor = colorFn(i, feature);\n        } else {\n          chosenColor = color as Color.IColor;\n        }\n\n        chosenColor = { ...chosenColor, a: chosenColor.a ?? opacity ?? 0 };\n\n        if (sizeFn) {\n          chosenSize = sizeFn(i, latLng);\n        } else {\n          chosenSize = size as number;\n        }\n\n        vertices.push(\n          // vertex\n          pixel.x,\n          pixel.y,\n\n          // color\n          chosenColor.r,\n          chosenColor.g,\n          chosenColor.b,\n          chosenColor.a ?? 0,\n\n          // size\n          chosenSize\n        );\n        const vertex: IPointVertex = {\n          latLng,\n          key,\n          pixel,\n          chosenColor,\n          chosenSize,\n          feature,\n        };\n        this.addLookup(vertex);\n        if (eachVertex) {\n          eachVertex(vertex);\n        }\n      }\n    }\n\n    return this;\n  }\n\n  // TODO: remove?\n  pointSize(pointIndex: number): number {\n    const { map, size } = this;\n    const pointSize =\n      typeof size === \"function\" ? size(pointIndex, null) : size;\n    // -- Scale to current zoom\n    const zoom = map.getZoom();\n    return pointSize === null ? Math.max(zoom - 4.0, 1.0) : pointSize;\n  }\n\n  drawOnCanvas(e: ICanvasOverlayDrawEvent): this {\n    if (!this.gl) return this;\n\n    const { gl, canvas, mapMatrix, matrix, map, allLatLngLookup } = this;\n    const { offset } = e;\n    const zoom = map.getZoom();\n    const scale = Math.pow(2, zoom);\n    // set base matrix to translate canvas pixel coordinates -> webgl coordinates\n    mapMatrix\n      .setSize(canvas.width, canvas.height)\n      .scaleTo(scale)\n      .translateTo(-offset.x, -offset.y);\n\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    gl.viewport(0, 0, canvas.width, canvas.height);\n    gl.uniformMatrix4fv(matrix, false, mapMatrix.array);\n    gl.drawArrays(gl.POINTS, 0, allLatLngLookup.length);\n\n    return this;\n  }\n\n  lookup(coords: LatLng): IPointVertex | null {\n    const latMax: number = coords.lat + 0.03;\n    const lngMax: number = coords.lng + 0.03;\n    const matches: IPointVertex[] = [];\n    let lat = coords.lat - 0.03;\n    let lng: number;\n    let foundI: number;\n    let foundMax: number;\n    let found: IPointVertex[];\n    let key: string;\n\n    for (; lat <= latMax; lat += 0.01) {\n      lng = coords.lng - 0.03;\n      for (; lng <= lngMax; lng += 0.01) {\n        key = lat.toFixed(2) + \"x\" + lng.toFixed(2);\n        found = this.latLngLookup[key];\n        if (found) {\n          foundI = 0;\n          foundMax = found.length;\n          for (; foundI < foundMax; foundI++) {\n            matches.push(found[foundI]);\n          }\n        }\n      }\n    }\n\n    const { map } = this;\n\n    // try matches first, if it is empty, try the data, and hope it isn't too big\n    return Points.closest(\n      coords,\n      matches.length > 0 ? matches : this.allLatLngLookup,\n      map\n    );\n  }\n\n  static closest(\n    targetLocation: LatLng,\n    points: IPointVertex[],\n    map: Map\n  ): IPointVertex | null {\n    if (points.length < 1) return null;\n    return points.reduce((prev, curr) => {\n      const prevDistance = locationDistance(targetLocation, prev.latLng, map);\n      const currDistance = locationDistance(targetLocation, curr.latLng, map);\n      return prevDistance < currDistance ? prev : curr;\n    });\n  }\n\n  // attempts to click the top-most Points instance\n  static tryClick(\n    e: LeafletMouseEvent,\n    map: Map,\n    instances: Points[]\n  ): boolean | undefined {\n    const closestFromEach: IPointVertex[] = [];\n    const instancesLookup: { [key: string]: Points } = {};\n    let result;\n    let settings: Partial<IPointsSettings> | null = null;\n    let pointLookup: IPointVertex | null;\n\n    instances.forEach((_instance: Points) => {\n      settings = _instance.settings;\n      if (!_instance.active) return;\n      if (_instance.map !== map) return;\n\n      pointLookup = _instance.lookup(e.latlng);\n      if (pointLookup === null) return;\n      instancesLookup[pointLookup.key] = _instance;\n      closestFromEach.push(pointLookup);\n    });\n\n    if (closestFromEach.length < 1) return;\n    if (!settings) return;\n\n    const found = this.closest(e.latlng, closestFromEach, map);\n\n    if (!found) return;\n\n    const instance = instancesLookup[found.key];\n    if (!instance) return;\n    const { sensitivity } = instance;\n    const foundLatLng = found.latLng;\n    const xy = map.latLngToLayerPoint(foundLatLng);\n\n    if (\n      pixelInCircle(xy, e.layerPoint, found.chosenSize * (sensitivity ?? 1))\n    ) {\n      result = instance.click(e, found.feature || found.latLng);\n      return result !== undefined ? result : true;\n    }\n  }\n\n  // hovers all touching Points instances\n  static tryHover(\n    e: LeafletMouseEvent,\n    map: Map,\n    instances: Points[]\n  ): Array<boolean | undefined> {\n    const results: boolean[] = [];\n    instances.forEach((_instance: Points): void => {\n      if (!_instance.active) return;\n      if (_instance.map !== map) return;\n      const pointLookup = _instance.lookup(e.latlng);\n      if (!pointLookup) return;\n      if (\n        pixelInCircle(\n          map.latLngToLayerPoint(pointLookup.latLng),\n          e.layerPoint,\n          pointLookup.chosenSize * _instance.sensitivityHover * 30\n        )\n      ) {\n        const result = _instance.hover(\n          e,\n          pointLookup.feature || pointLookup.latLng\n        );\n        if (result !== undefined) {\n          results.push(result);\n        }\n      }\n    });\n    return results;\n  }\n}\n","import earcut from \"earcut\";\nimport PolygonLookup from \"polygon-lookup\";\nimport geojsonFlatten from \"geojson-flatten\";\nimport { LatLng, LeafletMouseEvent, Map } from \"leaflet\";\nimport {\n  Feature,\n  FeatureCollection,\n  Geometry,\n  MultiPolygon,\n  Polygon,\n} from \"geojson\";\n\nimport {\n  BaseGlLayer,\n  ColorCallback,\n  IBaseGlLayerSettings,\n} from \"./base-gl-layer\";\nimport { ICanvasOverlayDrawEvent } from \"./canvas-overlay\";\nimport * as Color from \"./color\";\nimport { latLonToPixel } from \"./utils\";\n\nimport { notProperlyDefined } from \"./errors\";\n\nexport interface IShapesSettings extends IBaseGlLayerSettings {\n  border?: boolean;\n  borderOpacity?: number;\n  data: Feature | FeatureCollection | MultiPolygon;\n}\n\nexport const defaults: Partial<IShapesSettings> = {\n  color: Color.random,\n  className: \"\",\n  opacity: 0.5,\n  borderOpacity: 1,\n  shaderVariables: {\n    vertex: {\n      type: \"FLOAT\",\n      start: 0,\n      size: 2,\n    },\n    color: {\n      type: \"FLOAT\",\n      start: 2,\n      size: 4,\n    },\n  },\n  border: false,\n};\n\nexport class Shapes extends BaseGlLayer {\n  static defaults = defaults;\n  static maps: Map[];\n  settings: Partial<IShapesSettings>;\n  bytes = 6;\n  polygonLookup: PolygonLookup | null = null;\n\n  get border(): boolean {\n    if (typeof this.settings.border !== \"boolean\") {\n      throw new Error(notProperlyDefined(\"settings.border\"));\n    }\n    return this.settings.border;\n  }\n\n  get borderOpacity(): number {\n    if (typeof this.settings.borderOpacity !== \"number\") {\n      throw new Error(notProperlyDefined(\"settings.borderOpacity\"));\n    }\n    return this.settings.borderOpacity;\n  }\n\n  constructor(settings: Partial<IShapesSettings>) {\n    super(settings);\n    this.settings = { ...Shapes.defaults, ...settings };\n\n    if (!settings.data) {\n      throw new Error(notProperlyDefined(\"settings.data\"));\n    }\n    if (!settings.map) {\n      throw new Error(notProperlyDefined(\"settings.map\"));\n    }\n\n    this.setup().render();\n  }\n\n  render(): this {\n    this.resetVertices();\n    // triangles or point count\n\n    const { canvas, gl, layer, vertices, mapMatrix } = this;\n    const vertexBuffer = this.getBuffer(\"vertex\");\n    const vertexArray = new Float32Array(vertices);\n    const byteCount = vertexArray.BYTES_PER_ELEMENT;\n    const vertexLocation = this.getAttributeLocation(\"vertex\");\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, vertexArray, gl.STATIC_DRAW);\n    gl.vertexAttribPointer(\n      vertexLocation,\n      2,\n      gl.FLOAT,\n      false,\n      byteCount * this.bytes,\n      0\n    );\n    gl.enableVertexAttribArray(vertexLocation);\n\n    //  gl.disable(gl.DEPTH_TEST);\n    // ----------------------------\n    // look up the locations for the inputs to our shaders.\n    this.matrix = this.getUniformLocation(\"matrix\");\n\n    // Set the matrix to some that makes 1 unit 1 pixel.\n    gl.viewport(0, 0, canvas.width, canvas.height);\n    mapMatrix.setSize(canvas.width, canvas.height);\n    gl.uniformMatrix4fv(this.matrix, false, mapMatrix.array);\n\n    this.attachShaderVariables(byteCount);\n\n    layer.redraw();\n\n    return this;\n  }\n\n  resetVertices(): this {\n    this.vertices = [];\n    this.vertexLines = [];\n    this.polygonLookup = new PolygonLookup();\n\n    const {\n      vertices,\n      vertexLines,\n      polygonLookup,\n      map,\n      border,\n      opacity,\n      borderOpacity, // TODO: Make lookup for each shape priority, then fallback\n      color,\n      data,\n    } = this;\n    let pixel;\n    let index;\n    let features;\n    let feature;\n    let colorFn: ColorCallback | null = null;\n    let chosenColor: Color.IColor;\n    let coordinates;\n    let featureIndex = 0;\n    let triangles;\n    let indices;\n    let flat;\n    let dim;\n\n    switch (data.type) {\n      case \"Feature\":\n        polygonLookup.loadFeatureCollection({\n          type: \"FeatureCollection\",\n          features: [data],\n        });\n        features = geojsonFlatten(data);\n        break;\n      case \"MultiPolygon\": {\n        const geometry: Geometry = {\n          type: \"MultiPolygon\",\n          coordinates: data.coordinates,\n        };\n        polygonLookup.loadFeatureCollection({\n          type: \"FeatureCollection\",\n          features: [\n            {\n              type: \"Feature\" as const,\n              properties: {},\n              geometry,\n            },\n          ],\n        });\n        features = geojsonFlatten(data);\n        break;\n      }\n      default:\n        polygonLookup.loadFeatureCollection(data);\n        features = data.features;\n    }\n    const featureMax = features.length;\n\n    if (!color) {\n      throw new Error(notProperlyDefined(\"settings.color\"));\n    } else if (typeof color === \"function\") {\n      colorFn = color;\n    }\n\n    // -- data\n    for (; featureIndex < featureMax; featureIndex++) {\n      feature = features[featureIndex];\n      triangles = [];\n\n      // use colorFn function here if it exists\n      if (colorFn !== null) {\n        chosenColor = colorFn(featureIndex, feature);\n      } else {\n        chosenColor = color as Color.IColor;\n      }\n\n      const alpha = typeof chosenColor.a === \"number\" ? chosenColor.a : opacity;\n\n      coordinates = (feature.geometry || feature).coordinates;\n      if (!Array.isArray(coordinates[0])) {\n        continue;\n      }\n      flat = earcut.flatten(coordinates);\n      indices = earcut(flat.vertices, flat.holes, flat.dimensions);\n      dim = coordinates[0][0].length;\n      const { longitudeKey, latitudeKey } = this;\n      for (let i = 0, iMax = indices.length; i < iMax; i++) {\n        index = indices[i];\n        if (typeof flat.vertices[0] === \"number\") {\n          triangles.push(\n            flat.vertices[index * dim + longitudeKey],\n            flat.vertices[index * dim + latitudeKey]\n          );\n        } else {\n          throw new Error(\"unhandled polygon\");\n        }\n      }\n\n      for (let i = 0, iMax = triangles.length; i < iMax; i) {\n        pixel = map.project(new LatLng(triangles[i++], triangles[i++]), 0);\n        vertices.push(\n          pixel.x,\n          pixel.y,\n          chosenColor.r,\n          chosenColor.g,\n          chosenColor.b,\n          alpha\n        );\n      }\n\n      if (border) {\n        const lines = [];\n        for (let i = 1, iMax = flat.vertices.length; i < iMax; i = i + 2) {\n          lines.push(flat.vertices[i], flat.vertices[i - 1]);\n          lines.push(flat.vertices[i + 2], flat.vertices[i + 1]);\n        }\n\n        for (let i = 0, iMax = lines.length; i < iMax; i) {\n          pixel = latLonToPixel(lines[i++], lines[i++]);\n          vertexLines.push(\n            pixel.x,\n            pixel.y,\n            chosenColor.r,\n            chosenColor.g,\n            chosenColor.b,\n            borderOpacity\n          );\n        }\n      }\n    }\n\n    return this;\n  }\n\n  drawOnCanvas(e: ICanvasOverlayDrawEvent): this {\n    if (!this.gl) return this;\n\n    const { scale, offset, canvas } = e;\n    const { mapMatrix, gl, vertices, settings, vertexLines, border } = this;\n    // -- set base matrix to translate canvas pixel coordinates -> webgl coordinates\n    mapMatrix\n      .setSize(canvas.width, canvas.height)\n      .scaleTo(scale)\n      .translateTo(-offset.x, -offset.y);\n\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    gl.viewport(0, 0, canvas.width, canvas.height);\n\n    // -- attach matrix value to 'mapMatrix' uniform in shader\n    gl.uniformMatrix4fv(this.matrix, false, mapMatrix.array);\n    if (border) {\n      const vertexLinesBuffer = this.getBuffer(\"vertexLines\");\n      const vertexLinesTypedArray = new Float32Array(vertexLines);\n      const size = vertexLinesTypedArray.BYTES_PER_ELEMENT;\n      const vertex = this.getAttributeLocation(\"vertex\");\n      gl.bindBuffer(gl.ARRAY_BUFFER, null);\n      gl.bindBuffer(gl.ARRAY_BUFFER, vertexLinesBuffer);\n      gl.bufferData(gl.ARRAY_BUFFER, vertexLinesTypedArray, gl.STATIC_DRAW);\n\n      if (this.settings.shaderVariables !== null) {\n        this.attachShaderVariables(size);\n      }\n\n      gl.vertexAttribPointer(vertex, 3, gl.FLOAT, false, size * this.bytes, 0);\n      gl.enableVertexAttribArray(vertex);\n      gl.enable(gl.DEPTH_TEST);\n      gl.viewport(0, 0, canvas.width, canvas.height);\n      gl.drawArrays(gl.LINES, 0, vertexLines.length / this.bytes);\n\n      const vertexBuffer = this.getBuffer(\"vertex\");\n      const verticesTypedArray = new Float32Array(vertices);\n      gl.bindBuffer(gl.ARRAY_BUFFER, null);\n      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n      gl.bufferData(gl.ARRAY_BUFFER, verticesTypedArray, gl.STATIC_DRAW);\n\n      if (settings.shaderVariables !== null) {\n        this.attachShaderVariables(size);\n      }\n\n      gl.vertexAttribPointer(vertex, 2, gl.FLOAT, false, size * this.bytes, 0);\n      gl.enableVertexAttribArray(vertex);\n      gl.enable(gl.DEPTH_TEST);\n      gl.viewport(0, 0, canvas.width, canvas.height);\n    }\n    gl.drawArrays(gl.TRIANGLES, 0, vertices.length / this.bytes);\n\n    return this;\n  }\n\n  // attempts to click the top-most Shapes instance\n  static tryClick(\n    e: LeafletMouseEvent,\n    map: Map,\n    instances: Shapes[]\n  ): boolean | undefined {\n    let foundPolygon: Polygon | null = null;\n    let foundShapes: Shapes | null = null;\n    instances.forEach(function (_instance: Shapes): void {\n      if (!_instance.active) return;\n      if (_instance.map !== map) return;\n      if (!_instance.polygonLookup) return;\n\n      const polygon = _instance.polygonLookup.search(\n        e.latlng.lng,\n        e.latlng.lat\n      );\n      if (polygon) {\n        foundShapes = _instance;\n        foundPolygon = polygon;\n      }\n    });\n\n    if (foundShapes && foundPolygon) {\n      const result = (foundShapes as Shapes).click(e, foundPolygon);\n      return result !== undefined ? result : undefined;\n    }\n  }\n\n  // hovers all touching Shapes instances\n  static tryHover(\n    e: LeafletMouseEvent,\n    map: Map,\n    instances: Shapes[]\n  ): Array<boolean | undefined> {\n    const results: boolean[] = [];\n    let feature;\n\n    instances.forEach((_instance: Shapes): void => {\n      if (!_instance.active) return;\n      if (_instance.map !== map) return;\n      if (!_instance.polygonLookup) return;\n\n      feature = _instance.polygonLookup.search(e.latlng.lng, e.latlng.lat);\n\n      if (feature) {\n        const result = _instance.hover(e, feature);\n        if (result !== undefined) {\n          results.push(result);\n        }\n      }\n    });\n\n    return results;\n  }\n}\n","import { LeafletMouseEvent, Map } from \"leaflet\";\n\nimport { Lines, ILinesSettings } from \"./lines\";\nimport { Points, IPointsSettings } from \"./points\";\nimport { Shapes, IShapesSettings } from \"./shapes\";\nimport { debounce } from \"./utils\";\n\nimport vertex from \"./shader/vertex/default.glsl\";\nimport dot from \"./shader/fragment/dot.glsl\";\nimport point from \"./shader/fragment/point.glsl\";\nimport puck from \"./shader/fragment/puck.glsl\";\nimport simpleCircle from \"./shader/fragment/simple-circle.glsl\";\nimport square from \"./shader/fragment/square.glsl\";\nimport polygon from \"./shader/fragment/polygon.glsl\";\n\nconst shader = {\n  vertex,\n  fragment: {\n    dot,\n    point,\n    puck,\n    simpleCircle,\n    square,\n    polygon,\n  },\n};\n\nexport class Glify {\n  longitudeKey = 1;\n  latitudeKey = 0;\n  clickSetupMaps: Map[] = [];\n  hoverSetupMaps: Map[] = [];\n  shader = shader;\n\n  Points: typeof Points = Points;\n  Shapes: typeof Shapes = Shapes;\n  Lines: typeof Lines = Lines;\n\n  pointsInstances: Points[] = [];\n  shapesInstances: Shapes[] = [];\n  linesInstances: Lines[] = [];\n\n  longitudeFirst(): this {\n    this.longitudeKey = 0;\n    this.latitudeKey = 1;\n    return this;\n  }\n\n  latitudeFirst(): this {\n    this.latitudeKey = 0;\n    this.longitudeKey = 1;\n    return this;\n  }\n\n  get instances(): Array<Points | Lines | Shapes> {\n    return [\n      ...this.pointsInstances,\n      ...this.linesInstances,\n      ...this.shapesInstances,\n    ];\n  }\n\n  points(settings: Partial<IPointsSettings>): Points {\n    const points = new this.Points({\n      setupClick: this.setupClick.bind(this),\n      setupHover: this.setupHover.bind(this),\n      latitudeKey: glify.latitudeKey,\n      longitudeKey: glify.longitudeKey,\n      vertexShaderSource: () => {\n        return this.shader.vertex;\n      },\n      fragmentShaderSource: () => {\n        return this.shader.fragment.point;\n      },\n      ...settings,\n    });\n    this.pointsInstances.push(points);\n    return points;\n  }\n\n  lines(settings: Partial<ILinesSettings>): Lines {\n    const lines = new this.Lines({\n      setupClick: this.setupClick.bind(this),\n      setupHover: this.setupHover.bind(this),\n      latitudeKey: this.latitudeKey,\n      longitudeKey: this.longitudeKey,\n      vertexShaderSource: () => {\n        return this.shader.vertex;\n      },\n      fragmentShaderSource: () => {\n        return this.shader.fragment.polygon;\n      },\n      ...settings,\n    });\n    this.linesInstances.push(lines);\n    return lines;\n  }\n\n  shapes(settings: Partial<IShapesSettings>): Shapes {\n    const shapes = new this.Shapes({\n      setupClick: this.setupClick.bind(this),\n      setupHover: this.setupHover.bind(this),\n      latitudeKey: this.latitudeKey,\n      longitudeKey: this.longitudeKey,\n      vertexShaderSource: () => {\n        return this.shader.vertex;\n      },\n      fragmentShaderSource: () => {\n        return this.shader.fragment.polygon;\n      },\n      ...settings,\n    });\n    this.shapesInstances.push(shapes);\n    return shapes;\n  }\n\n  setupClick(map: Map): void {\n    if (this.clickSetupMaps.includes(map)) return;\n    this.clickSetupMaps.push(map);\n    map.on(\"click\", (e: LeafletMouseEvent) => {\n      let hit;\n      hit = this.Points.tryClick(e, map, this.pointsInstances);\n      if (hit !== undefined) return hit;\n\n      hit = this.Lines.tryClick(e, map, this.linesInstances);\n      if (hit !== undefined) return hit;\n\n      hit = this.Shapes.tryClick(e, map, this.shapesInstances);\n      if (hit !== undefined) return hit;\n    });\n  }\n\n  setupHover(map: Map, hoverWait?: number, immediate?: false): void {\n    if (this.hoverSetupMaps.includes(map)) return;\n    this.hoverSetupMaps.push(map);\n    map.on(\n      \"mousemove\",\n      debounce(\n        (e: LeafletMouseEvent) => {\n          this.Points.tryHover(e, map, this.pointsInstances);\n          this.Lines.tryHover(e, map, this.linesInstances);\n          this.Shapes.tryHover(e, map, this.shapesInstances);\n        },\n        hoverWait ?? 0,\n        immediate\n      )\n    );\n  }\n}\n\nexport const glify = new Glify();\nexport default glify;\nif (typeof window !== \"undefined\" && window.L) {\n  // @ts-expect-error exporting it to window\n  window.L.glify = glify;\n  // @ts-expect-error exporting it to window\n  window.L.Glify = Glify;\n}\n"]}